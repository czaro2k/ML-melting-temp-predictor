# -*- coding: utf-8 -*-
"""PL_Temp_Predictor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MJrqKLEvCLjHjeqCUh2oU3SnEJxOavi7
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install rdkit

"""# Nowa sekcja"""

import re
import csv
from keras.models import Sequential
from keras.layers import Dense
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd 
from rdkit import Chem
from google.colab import files
from sklearn.ensemble import RandomForestRegressor
from rdkit.Chem import Fragments
from rdkit.Chem import Descriptors
from sklearn.model_selection import train_test_split
from rdkit.ML.Descriptors import MoleculeDescriptors
from rdkit.Chem.FragmentMatcher import FragmentMatcher
from rdkit.ML.Descriptors.MoleculeDescriptors import MolecularDescriptorCalculator
from sklearn.metrics import mean_squared_error

def update_temp(temp_string):
  if temp_string.find("-") > 0:
    values = temp_string.split("-")
    new_temp_string = (float(values[0])+float(values[1])) / 2.0
  else:
    new_temp_string = float(temp_string)
  return new_temp_string

def is_valid(smiles):
    return Chem.MolFromSmiles(smiles) is not None

def desc(smiles):
  return list(mol_descriptor_calculator.CalcDescriptors(Chem.MolFromSmiles(smiles)))

used_descriptors  = ['NumAliphaticCarbocycles', 'MolMR', 'MolWt', 'NHOHCount','BalabanJ', 'BertzCT', 'TPSA','PEOE_VSA10','NumAliphaticHeterocycles', 'NumAliphaticRings', 
                     'NumAromaticCarbocycles', 'NumAromaticHeterocycles', 'NumAromaticRings', 'NumHAcceptors', 'NumHDonors', 'NumHeteroatoms', 'NumRadicalElectrons',
                     'NumRotatableBonds', 'NumSaturatedCarbocycles', 'NumSaturatedHeterocycles', 'NumSaturatedRings', 'NumValenceElectrons','fr_Al_COO', 'fr_Al_OH', 
                     'fr_Al_OH_noTert', 'fr_ArN', 'fr_Ar_COO', 'fr_Ar_N', 'fr_Ar_NH', 'fr_Ar_OH', 'fr_COO', 'fr_COO2', 'fr_C_O', 'fr_C_O_noCOO', 'fr_C_S', 'fr_HOCCN', 
                     'fr_Imine', 'fr_NH0', 'fr_NH1', 'fr_NH2', 'fr_N_O', 'fr_Ndealkylation1', 'fr_Ndealkylation2', 'fr_Nhpyrrole', 'fr_SH', 'fr_aldehyde', 'fr_alkyl_carbamate', 
                     'fr_alkyl_halide', 'fr_allylic_oxid', 'fr_amide', 'fr_amidine', 'fr_aniline', 'fr_aryl_methyl', 'fr_azide', 'fr_azo', 'fr_barbitur', 'fr_benzene', 
                     'fr_benzodiazepine', 'fr_bicyclic', 'fr_diazo', 'fr_dihydropyridine', 'fr_epoxide', 'fr_ester', 'fr_ether', 'fr_furan', 'fr_guanido', 'fr_halogen', 
                     'fr_hdrzine', 'fr_hdrzone', 'fr_imidazole', 'fr_imide', 'fr_isocyan','fr_isothiocyan', 'fr_ketone', 'fr_ketone_Topliss', 'fr_lactam', 'fr_lactone',
                     'fr_methoxy', 'fr_morpholine', 'fr_nitrile', 'fr_nitro', 'fr_nitro_arom', 'fr_nitro_arom_nonortho', 'fr_nitroso', 'fr_oxazole', 'fr_oxime', 
                     'fr_para_hydroxylation', 'fr_phenol', 'fr_phenol_noOrthoHbond', 'fr_phos_acid', 'fr_phos_ester', 'fr_piperdine', 'fr_piperzine', 'fr_priamide', 
                     'fr_prisulfonamd', 'fr_pyridine', 'fr_quatN', 'fr_sulfide', 'fr_sulfonamd', 'fr_sulfone', 'fr_term_acetylene', 'fr_tetrazole', 'fr_thiazole',
                     'fr_thiocyan', 'fr_thiophene', 'fr_unbrch_alkane', 'fr_urea',]


mol_descriptor_calculator = MolecularDescriptorCalculator(used_descriptors)

hn = ['full_name', 'formula', 'boiling_temp', 'melting_temp', 'SMILES']

df = pd.read_csv("dane.tsv",sep='\t', names = hn)

df = df[[df.columns[4],df.columns[3]]]

df = df.replace('\xa0', np.nan, regex=True)
df['melting_temp'] = df['melting_temp'].replace('[a-z]*', '', regex=True)
df = df.replace('>', '', regex=True)

df.dropna(axis='rows', inplace=True)

df.index = pd.RangeIndex(len(df.index))
df.index = range(len(df.index))

df['melting_temp'] = df.apply(lambda row: update_temp(row[1]), axis=1)

df['valid'] = df['SMILES'].apply(is_valid)
df = df[df['valid'] == True]

df['descriptor'] = df['SMILES'].apply(desc)

df['desc_sum'] = df['descriptor'].map(sum)
df = df[df['desc_sum'] != 0]

df = df.drop(columns = ['desc_sum','valid'])

#df.to_csv('processed_data.csv', encoding = 'utf-8-sig')
#files.download('processed_data.csv')

df

X = []

for i in range(len(df)):
  X.append(desc(df['SMILES'].iloc[i]))

X = np.array(X)
y = np.array(df["melting_temp"].values)

print(X.shape, y.shape)

def plot_model(model):
  Y_pred = model.predict(X)

  plt.figure(figsize=(6, 6))
  plt.scatter(Y_pred, y)
  plt.xlabel('Predicted Values')
  plt.ylabel('Actual Values')

  x_diag = np.linspace(-270,3500, num=10000)
  y_diag = np.linspace(-270,3500, num=10000)
  plt.plot(x_diag, y_diag, color='red')

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=420)

rfr = RandomForestRegressor(n_estimators=50, random_state=42)
rfr.fit(X_train, y_train)

print('score: ', rfr.score(X_test, y_test))

print('MSE test:', mean_squared_error(y_test, rfr.predict(X_test)))
print('MSE all:', mean_squared_error(y, rfr.predict(X)))

print('MAE test:', np.sqrt(mean_squared_error(y_test, rfr.predict(X_test))))
print('MAE all:', np.sqrt(mean_squared_error(y, rfr.predict(X))))

plot_model(rfr)
plt.show()

df['predicted_temp'] = df.apply(lambda row: rfr.predict([row['descriptor']])[0], axis=1)

df[abs(df['melting_temp'] - df['predicted_temp']) >= 50]

def plot_learning(hist,eps):
  history = hist
  plt.plot(history.history['loss'])
  plt.plot(history.history['val_loss'])
  plt.xlabel('Epoch')
  plt.ylabel('Loss')
  plt.legend(['train', 'validation'], loc='upper left')

eps = 150

model = Sequential()
model.add(Dense(128, input_dim=X.shape[1], activation='relu'))
model.add(Dense(64, activation='relu'))
model.add(Dense(32, activation='relu'))
model.add(Dense(16, activation='relu'))
model.add(Dense(1, activation='linear'))

error = model.compile(loss='mean_absolute_error', optimizer='adam')

history = model.fit(X_train, y_train, epochs=eps, batch_size=32, verbose=2, validation_data=(X_test, y_test))

score = model.evaluate(X_test, y_test, verbose=0)

print("Test mean absolute error:", score)

plot_model(model)
plt.savefig("model.png")
plt.show()

plot_learning(history, eps)
plt.savefig("model_learning.png")
plt.show()